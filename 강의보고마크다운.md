## jpa 내용
 > [인용글](https://ict-nroo.tistory.com/130)입니다.    

JPA에 있어 가장 중요한 개념은 객체와 관계형 데이터 베이스를 매핑하는 기술과 영속성 컨텍스트를 이해하는 것이다.   
* 즉시 로딩 지연 로딩   
OpenSessionReview   
지연로딩을 사용하게된 이유를 물어봤을때    
트랜잭션 밖에서 동작하지 않는다. >> 타선책이 있으니 다른 이유를 얘기하기       

* 생성자에 new ArraryList를 할 수 있지만 null문제를 피하기 위해서 또 다른 이유는 hibernate가 persistence하는 동안 컬렉션을 한번 감싸기 때문에(Hibernate의 자체적으로 지원하는 컬렉션으로 감싸게 된다.  >> 영속성 컨텍스트의  관리가 필요하기 때문에 Hibernate의 자체 컬력션을 사용하게 된다.)


  * 엔티 매니저 팩토리와 
    * [@Transactional 사용시](https://mommoo.tistory.com/92)
    * [자바 표준 JPA프로그래밍 강의 정리본](https://velog.io/@conatuseus/JPA-%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%ED%83%80%EC%9E%85embedded-type-8ak3ygq8wo)
    * [지연 로딩 , 즉시 로딩](https://ict-nroo.tistory.com/132?category=826875)

casecade 의미    
엔티팉의 상태 변화를 전파 시키는 옵션    
`OneToMany`와 `ManyToOne`로 양방향 관계를 맺는 엔티티의 상태 변활르 전이시킬 때 사용     
부모 엔티티를 저장 할때 자식 엔티티도 함께 저장할 수 있다.   
엔티티간 persistent를 각기 해주어야하는 부분에 있어 cascase를 사용시 편리하게 해준다.
```
OrderItem을 등록하는 Order가 등록하는 상황이며 
casecade의 차이을 보여주기 위해서 코드 확인 
persist(OrderItem1)
persist(OrderItem2)
persist(OrderItem3)
persist(order)

//casecade 적용시
persist(order)
```

연관 관계 메소드    
양방향 관계에서 데이터 삽입간 메소드를 편리하게 사용하기 위해서 연관관계 메소드를 사용한다. 메소드 작성시 Entity를 컨트롤하는쪽이 메소드를 가지고 있는것이 유용하게 사용할 수 잇다.
```
public void setMember(Member member){
  this.member=  member;
  member.getOrder().add(this);
}

public static void main{
  //연관 관계 메소드를 사용하지 않게 된다면
  Member member = new Member();
  Order order = new Order();
  //Business logic >> Entity접근시 getter는 사용가능하나 settter는 되도록이면 사용
  member.getOrder().add(order);
  order.setMember(member)
  // 두 코드를 묶어주기 위해서 연관관계 메소드를 사용한다.   
} 
```


JPQL ??   
`select m fom Member m` >> 해당 문장을 JPQL이라고 하며 기존 sql과 동작하는 방식은 동일하나 다른점은 SQL은 Table을 관련하여 query가 동작하게 되지만 JPQL은 Entity를 기준으로 query가 동작하게 된다.


@PersistenceContext    
`@PersistenceContext` 스프링 부트에서 PersisistenceContext 애노테이션을 통해서 EntityManager를 DI하게 된다. 기존 스프링 부트를 사용하지 않게 된다면 `EntityFactory`를 통해서 `EntityManager`를 생성하여 사용해야하지만 이러 번거러움을 스프링부트가 대신 해준다.    
영속성 컨텍스트 생명 주기 확인해보기 현재로는 persist > flush >> commit한다고 알고 있음    


Entity 속성중 cascade가 속성을 사용하게 되면 해당 Entity가 persist 하게 되면 cascade 옵션이 추가 되어 있는 Entity들이 자동으로 commit 되게 된다.   
하지만 자동으로 commit되어 장점인 부분도 있지만 어디까지 commit되는지는 알지못하기 때문에 주의하고 사용하여야 한다.   
cascade는 참조 관계를 이루고 있으며 참조 관계를 이루고 있는 테이블이 해당 관리 중인 참조 관계를 제외 하고 다른 테이블과 참조 관계를 이루고 있을때는 사용하지 않는 것이 좋다.    


Entity 생성자 메소드 protected 활용    
protected 생성자 함수를 통해 다른 패키지에 Entity를 생성자 함수 및 setter를 활용하지 못하도록 막기 위해 사용한다.   
접근 제어자의 활용이 중요한 부분!!    


    
검색기능 구현에 있어 JPA를 통한 동적 쿼리 사용 방식   
QuertDSL을 사용하지 않고 기존 JPA 표준 스펙의 메소드를 활용하여 동적쿼리 생성 코드
```
/**
     * 동적쿼리를 생성 또는 JPQL을 생성하기 위한 JPA 표준 스팩에 기제 되어 있는 방식으로 일단 해결 향후는 MyBatis 또는 QueryDSL 사용하여 줄이기
     */
    public List<Order> findBtCriteria(OrderSearch orderSearch){
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<Order> cq = cb.createQuery(Order.class);
        Root<Order> o = cq.from(Order.class);
        Join<Object, Object> m = o.join("member", JoinType.INNER);

        List<Predicate> criteria = new ArrayList<>();

        if (orderSearch.getOrderStatus() != null) {
            Predicate status = cb.equal(o.get("status"), orderSearch.getOrderStatus());
            criteria.add(status);
        }
        if (StringUtils.hasText(orderSearch.getMemberName())) {
            Predicate name = cb.like(m.get("name"), "%" + orderSearch.getMemberName() + "%");
            criteria.add(name);
        }
        cq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));
        TypedQuery<Order> orderTypedQuery = em.createQuery(cq).setMaxResults(1000);
        return orderTypedQuery.getResultList();
    }
``` 


변경감지 와 병합 중요한 개념 
변경감지 - dirty cheking이라고 말하며 JPA 엔티티의 변화를 flush하는 시점에 변경 감지가 발생하게 된다.   
준영속성 컨텍스트   
영속성 컨텍스트에서 더이상 관리 되어 지지 않는 상태    
예를 들어 상품을 등록하고 수정하는 페이지에서 수정후 submit할때 사용자가 제출한 정보에 대한 객체를 new 해서 생성하게 되는데 실질적으로 인스턴스화된 데이터가 아닌 데이터에서 존재하는 데이터를 관리할 수 있게 된다.
```
@Autowired
private final EntityManager em;
em.persist()
em.merge()
```  
상단의 코드와 같이 `EntityManager`인터페이스를 통해서 Entity를 관리하게 되면 영속성 컨텍스트가 관리하게 되지만 상단의 예제로 진행한 방식은 setter를 통해서 수정한다음 서비스 계층의 비즈니스 메소드를 사용하여 변경하기 떄문에 영속성 컨텍스트가 아닌 준영속성 컨텍스트를 통해서 수정하는 차이를 확인할 수 있게 된다.    
그렇다면 준영속성 컨텍스트에 포함된 Entitiy는 어떻게 변화를 줄 수 있을까?   
  * 변경 감지 기능
    ```
    @Transactional
    public void updateItem(Long itemId , Book param){
      Item findItem = itemRepository.findItem(itemId)
      findItem.setName(param.getName())
      findItem.setPrice(param.getPrice())
      findItem.setStockQuatity(param.getStockQuatity())
    }
    ```
    상단의 코드와 같이 JPA와 관리하는 영속성 컨텍스트를 직접 접근하여 해당 식별자를 통해서 객체를 찾아와 setter를 활용하여 Entity의 값을 변경하는것을 확인할 수 있는데 중요한 부분은 `@Transactional`을 통해 **commit**이 발생하게 그 후 **flush**를 하게 된다.   
      * flush는 영속성 컨텍스틍에 존재하는 엔티티의 변경된 부분을 확인을 하는 시점이라고 생각!!

  * 병합 (merge) 사용    
    병합은 준영속 상태의 엔티티 영속 상태로 변경할때 사용하는 기능    
    상단의 코드와 동일하게 동작하며 주의할점이 있다.
    1. 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회
    2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체
    3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터 베이스에 UPDATE SQL이 실행된다.
    ```
        //해당 코드는 EntityManager 인터페이스를 통해 구현되어진 영속성 컨텍스트를 통해서 관리 되어 지고 있는 구현체를 통해서 로직이 동작하는것을 볼 수 있다.
        public void save(Item item){
          if (item.getId() == null) {
              em.persist(item);
          }else{
              // 해당 merge는 준영속성에서 영속성 상태로 변경하여 엔티티의 변경점을 찾아 변경해주게된다.
              em.merge(item);
          }
      }

    ```      
    ```
    Item item = em.merge(item);
    ```
   **해당 코드에서 return 되는 값은 영속성 컨텍스트에 포함되지만 merge에 사용되는 파라메터값은 준영속성 컨텍스트에 포함되는것은 주의하며 추가적인 로직을 작성할때 주의하고 사용해야한다.**   

**하지만 변경 감지 기능을 사용하게 되면 원하는 속성만 변경을 감지하여 변경하지만 merge(병합)을 하게 되다면 모든 속성을 변경하게 된다.**  


setter를 통해 데이터 변경하는 습관보다는 의미 있는 메소드를 기반으로 변경하는 로직 선언하는것을 선호해야한다.     
더나은 코드를 만들기 위한 다양한 방법들이 있으며 하나의 예를 들 수 있다.
```
이와 같이 Controller에 선언되어 있는 메소드를 확인 할 수 있다.
@PostMapping("items/{itemId}/edit")
    public String updateItem(@ModelAttribute("form") BookForm form) {
        Book book = new Book();
        book.setAuthor(form.getAuthor());
        book.setIsbn(form.getIsbn());
        book.setPrice(form.getPrice());
        book.setId(form.getId());
        book.setStackQuantity(form.getStockQuantity());
        itemSerrvice.saveItem(book);
        return "redirect:/items";
    }
```
setter를 통해서 merge하는 코드를 제거하기 위해 
```
@Transactional
public void findItemUpdateItem(Long itemId , int price , String name){
  Item findItem = itemRepository.findOne(itemId)
  findItem.setName(name)
  findItem.setPrice(price)
}
```
해당 코드를 Service에 메소드로 선언하여 
```
@PostMapping("items/{itemId}/edit")
    public String updateItem@PathVariable("itemId") Long id,(@ModelAttribute("form") BookForm form) {
        itemService.findItemUpdateItem(id,form.getPrice,form.getName())
        return "redirect:/items";
    }
```
아래 서비스 계층에서 메소드를 선언하여 merge를 제거하고 변경 감지를 통해서 변경된 데이터만 변경될 수 있도록 로직을 정의하였다.  
또한 `itemService.findItemUpdateItem(id,form.getPrice,form.getName())`부분의 파라메터값을 넣는 부분을 좀더 명시적으로 변경하기 위해서 **DTO(Data Transform Obejct)**를 통해서 가공된 데이터를 한번에 전송할 수 있다.   

---

## DataBase 관련 내용
* DB multi index 


[데이터 베이스 커서](https://velog.io/@amuse/database-Cursor-%EC%BB%A4%EC%84%9C%EB%9E%80%EC%9E%91%EC%84%B1%EC%A4%91)     
그런데 정말 100만건을 한번에 조회하고 싶으면 커서라는 기능을 사용하면 됩니다. 이 기능으로 조회하면 데이터베이스는 결과를 내부에 저장해두고 애플리케이션에서 달라고 할 때 마다 조금씩 전송해줍니다. 이렇게 되려면 중요한게 애플리케이션과 DB간에 커넥션이 계속 연결되어있어야 하고, 추가로 DB도 해당 데이터를 어딘가에 보관해두어야 합니다.   
그런데 여기서! The object is already closed라는 뜻은 뭔가 이 커서 데이터가 끊어저 버렸다는 뜻입니다.

이 커서가 끊어지는 것은 데이터베이스마다 다르지만 일반적으로 커넥션이 종료되거나, 또는 트랜잭션이 커밋되어 버리는 경우입니다. 트랜잭션 커밋의 경우 데이터베이스 마다 다릅니다. 트랜잭션이 커밋되어도 커서를 유지하는 옵션을 제공하기도 합니다.

Truestar님의 경우는 바로 서비스 계층에서 트랜잭션이 커밋되어서 커서가 끊어저버려서 그렇습니다. 아마 서비스 계층에서 스프림을 돌리면 되고, 트랜잭션이 끝난 컨트롤러에서 스트림을 동작해보면 해당 오류가 발생할꺼에요^^
.     
[데이터 베이스 모델링 공부](https://www.youtube.com/watch?v=Toh3WKTRaW8)  
## Spring 관련 내용

* 세팅 application.properties 보다는 application.yml이용하자    
[yml정보](https://goddaehee.tistory.com/213)   
[yml jpa적용](https://getinthere.tistory.com/20)

## 번외
* DAO , DTO , AO , Entitiy정리


테스트 코드 작성시 요령    
단위 테스트 구현을 중점으로 진행   
비즈니스 로직 자체를 Mocking을 진행하여 테스트  코드 작성 , db사용하지 않고 , spring 제외한 상태의 테스트 코드 짤줄 알아야한다.    


현재 프로젝트 진행에 있어 Entity와 Service를 분리하여 구현을 진행하고 있는데 Entity에 비즈니스 로직 메소드를 선언하여 진행하는 방향으로 진행하고 있다.    
혼란스러운 부분은 Enitity와 Service 둘중 어떤 곳에 비즈니스로직 메소드를 선언하는것이 올바른 설계인지 몰라서 찾아보던중     
아래와 같은 포스팅 글을 보게 된다.    

도메인이 비즈니스 로직의 주도권을 가지고 개발하는것을 도메일 주도 설계라 하며 이렇게 해두면 서비스의 많은 로직이 Entity로 이동하고 Serivce는 Entity를 호출하는 정도의 얇은 비즈니스 로직을 가지게 된다.(information export pattern)이라고 한다.    
반대로 Entity는 단숭히 getter setter만 제공하고 Service에 비즈니스 로직이 모두 있어도 된다고 하며 서비스의 로직은 커지게 되고 엔티티는 단순하게 데이터를 전달하는 역할로만 사용된다고 한다.   
전자는 엔티티를 객체로 , 후자는 엔티티를 자료구조로 사용하게 되는데 이부분에서는 서로차이가 있어 상황별로 설계를 하는방향으로 진행해애한다고한다.   
  * [전자 관련 포스팅글](https://ssaturn.tistory.com/176)
    * [DDD도입에 있어 발생한 문제점](http://jaynewho.com/post/45)
  * [후자 관련 포스팅 글](http://amaz ingguni.github.io/blog/2016/05/Clean-Code-6-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0)   

부가적인 설명은로는 Entity에 부가적인 비즈니스 로직을 추가하는것을 **도메인 모델 패턴**이라고 한다.(객체 지향 특성 활용) , 서비스 계층은 단순히 엔티티에 필요한 여청을 위임하는 역할을 한다.반대로 Entity에는 비즈니스 로직이 존재하지 않고 서비스 계층에서 대부분의 비즈니스 로직을 처리하는것을 **트랜잭션 스크립트 패턴**이라고 한다.    
도메인 모델 패턴으로 코드 작성의 장점 DB연동 없이 Entity자체을 테스트하는 코드를 작성하는 부분에서 강점을 가지고 있다.  


화면에 관련되 데이터를 만들때는 DTO ,Form class를 따로 선언해서 처리
  
  




